/**
 * serveur.c
 */

// On importe des fichiers.h nécéssaires à l'application
#include <stdio.h>      // Fichier contenant les en-têtes des fonctions standard d'entrées/sorties 
#include <stdlib.h>     // Fichier contenant les en-têtes de fonctions standard telles que malloc()
#include <string.h>     // Fichier contenant les en-têtes de fonctions standard de gestion de chaînes de caractères 
#include <unistd.h>     // Fichier d'en-têtes de fonctions de la norme POSIX (dont gestion des fichiers : write(), close(), ...)
#include <sys/types.h>      // Fichier d'en-têtes contenant la définition de plusieurs types et de structures primitifs (système)
#include <sys/socket.h>     // Fichier d'en-têtes des fonctions de gestion de sockets
#include <netinet/in.h>     // Fichier contenant différentes macros et constantes facilitant l'utilisation du protocole IP
#include <netdb.h>      // Fichier d'en-têtes contenant la définition de fonctions et de structures permettant d'obtenir des informations sur le réseau (gethostbyname(), struct hostent, ...)
#include <memory.h>     // Contient l'inclusion de string.h (s'il n'est pas déjà inclus) et de features.h
#include <errno.h>      // Fichier d'en-têtes pour la gestion des erreurs (notamment perror()) 

#define P 12332

/*
  creersock

  Il s'agit de la fonction qui va permettre la création d'une socket.
  Elle est utilisée dans la fonction main().
  Elle prend en paramètre un entier court non signé, qui est le numéro de port,
  nécéssaire à l'opération bind().
  Cette fonction renvoie un numéro qui permet d'identifier la socket nouvellement créée
  (ou la valeur -1 si l'opération a échouée).
*/

// version udp de creersock
int creersockudp( u_short port) {

  int sock, retour;

  // On crée une variable adresse selon la structure sockaddr_in
  struct sockaddr_in adresse;
  
  sock = socket(AF_INET,SOCK_DGRAM,0);

  // Si le code retourné n'est pas un identifiant valide (la création s'est mal passée), on affiche un message sur la sortie d'erreur, et on renvoie -1
  if (sock<0) {
    perror ("ERREUR OUVERTURE");
    return(-1);
  }
  
  // On complète les champs de la structure sockaddr_in
  adresse.sin_family = AF_INET;

  adresse.sin_port = htons(port);

  adresse.sin_addr.s_addr=INADDR_ANY;

  retour = bind (sock,(struct sockaddr *)&adresse,sizeof(adresse));
  
  // En cas d'erreur lors du bind, on affiche un message d'erreur et on renvoie -1
  if (retour<0) {
    perror ("IMPOSSIBLE DE NOMMER LA SOCKET");
    return(-1);
  }

  // Au final, on renvoie sock, qui contient l'identifiant à la socket crée et attachée.
  return (sock);
}

// version tcp de creersock
int creersocktcp( u_short port) {

  int sock, retour;

  // On crée une variable adresse selon la structure sockaddr_in (la structure est décrite dans sys/socket.h)
  struct sockaddr_in adresse;
  
  sock = socket(AF_INET,SOCK_STREAM,0);

  // Si le code retourné n'est pas un identifiant valide (la création s'est mal passée), on affiche un message sur la sortie d'erreur, et on renvoie -1
  if (sock<0) {
    perror ("ERREUR OUVERTURE");
    return(-1);
  }
  
  // On complète les champs de la structure sockaddr_in : 
  // La famille du socket, AF_INET, comme cité précédement
  adresse.sin_family = AF_INET;

  adresse.sin_port = htons(port);

  adresse.sin_addr.s_addr=INADDR_ANY;
  
  retour = bind (sock,(struct sockaddr *)&adresse,sizeof(adresse));
  
  // En cas d'erreur lors du bind, on affiche un message d'erreur et on renvoie -1
  if (retour<0) {
    perror ("IMPOSSIBLE DE NOMMER LA SOCKET");
    return(-1);
  }

  // Au final, on renvoie sock, qui contient l'identifiant à la socket crée et attachée.
  return (sock);
}

int main (int argc, char* argv[]) {

  if(argc < 2)
    {
      printf("port(s) manquant(s).\n");
      return 1;
    }

  // On définit les variables nécéssaires
  int *socks, i, s, sock, msgsock, udp, tcp;
  fd_set fd_read, fd_write;
  unsigned int len;
  struct sockaddr addr;
  char msg [BUFSIZ];
  
  // On crée les sockets
  socks = (int*)malloc(2*(argc-1)*sizeof(int));
  for(i = 0; i < argc-1; i++)
    {
      socks[i] = creersockudp(atoi(argv[i+1]));
      socks[i+argc] = creersocktcp(atoi(argv[i+1]));
      listen(socks[i+argc], 5);
    }

  while(1)
    {
      udp = 0;
      tcp = 0;
      FD_ZERO(&fd_read);
      FD_ZERO(&fd_write);

      for(i = 0; i < argc-1; i++)
	{
	  FD_SET(socks[i], &fd_read);
	  FD_SET(socks[i+argc], &fd_read);
	}

      select(socks[2*argc-2]+1, &fd_read, 0, 0, 0);
      if(fork() == 0)
	{
	  for(i = 0; i < argc-1; i++)
	    {
	      if(FD_ISSET(socks[i], &fd_read))
		{
		  sock = socks[i];
		  udp = 1;
		  break;
		}
	      else if(FD_ISSET(socks[i+argc], &fd_read))
		{
		  sock = socks[i+argc];
		  tcp = 1;
		  break;
		}
	    }
	  if(udp)
	    {
	      fils_udp(sock);	      
	    }
	  else if(tcp)
	    {
	      fils_tcp(sock);
	    }
	  exit(EXIT_SUCCESS);
	}
    }

  // On referme les sockets d'écoute.
  for(i = 0; i < argc-1; i++)
    {
      close(socks[i]);
      close(socks[i+argc]);
    }

  exit(EXIT_SUCCESS);
}

int fils_udp(int sock)
{
  len = sizeof(addr);
  s = recvfrom(sock, msg, 1024, 0, &addr, &len);

  if(s == -1)
    perror("Problemes");
  else
    {
      // Si le code d'erreur est bon, on affiche le message.
      msg[s] = 0;
      printf("Msg: %s\n", msg);
      printf("Recept reussie, emission msg: ");

      // On demande à l'utilisateur de rentrer un message qui va être expédié sur le réseau
      msg[0] = '\0';
      scanf(" %[^\n]", msg);
    
      // On va écrire sur la socket, en testant le code d'erreur de la fonction write.
      s = sendto(sock, msg, strlen(msg), 0,  &addr, len);
      if (s == -1) {
	perror("Erreur sendto");
	return(-1);
      }
      else
	printf("Ecriture reussie, msg: %s\n", msg);
    }
  return 0;
}

int fils_tcp(int sock)
{
  int msgsock;
  msgsock = accept (sock, (struct sockaddr *) 0, (unsigned int*) 0);
  // Si l'accept se passe mal, on quitte le programme en affichant un message d'erreur.
  if (msgsock == -1) {
    perror("Erreur accept");
    return(-1);
  }
  else
    printf("Accept reussi");
  
  // On lit le message envoyé par la socket de communication. 
  //  msg contiendra la chaine de caractères envoyée par le réseau,
  // s le code d'erreur de la fonction. -1 si pb et sinon c'est le nombre de caractères lus
  if(!libre())
    write(msgsock, "Ressource en cours d'utlisation, merci de patienter...", 1024);
  while(!libre());
  s = read(msgsock, msg, 1024);
  

  if (s == -1)
    perror("Problemes");
  else {

    // Si le code d'erreur est bon, on affiche le message.
    msg[s] = 0;
    printf("Msg: %s\n", msg);
    printf("Recept reussie, emission msg: ");

    // On demande à l'utilisateur de rentrer un message qui va être expédié sur le réseau
    msg[0] = '\0';
    scanf(" %[^\n]", msg);
    
    // On va écrire sur la socket, en testant le code d'erreur de la fonction write.
    s = write(msgsock, msg, strlen(msg));
    if (s == -1) {
      perror("Erreur write");
      return(-1);
    }
    else
      printf("Ecriture reussie, msg: %s\n", msg);
    // On referme la socket de communication
    close(msgsock);
  }
  return 0;
}

int libre()
{
  return (1)
}
